const Invoice = require("../models/Invoice");
const Sale = require("../models/Sale");
const Purchase = require("../models/Purchase");
const { getNepaliCurrentDateTime } = require("../utils/dateUtils");

// Helper function to generate invoice from sale
const generateInvoiceFromSale = async (sale, userInfo = {}) => {
  try {
    // Calculate due date (30 days from now)
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 30);

    // Use the same invoice number as the sale
    const invoiceNumber = sale.invoiceNumber;

    const invoiceData = {
      invoiceNumber: invoiceNumber,
      type: "sale",
      relatedId: sale._id,
      relatedModel: "Sale",
      customerName: sale.customerName,
      customerEmail: sale.customerEmail,
      customerPhone: sale.customerPhone,
      items: sale.items.map(item => ({
        inventoryId: item.inventoryId,
        name: item.name,
        quantity: item.quantity,
        price: item.price,
        total: item.total,
      })),
      subtotal: sale.subtotal,
      tax: sale.tax,
      discount: sale.discount,
      total: sale.total,
      dueDate: dueDate,
      issueDate: sale.createdAt || new Date(),
      paymentStatus: sale.paymentStatus,
      paidAmount: sale.paidAmount,
      paymentMethod: sale.paymentMethod,
      status: sale.paymentStatus === "paid" ? "paid" : "sent",
      autoGenerated: true,
      generatedFrom: "sale",
      createdBy: userInfo,
      notes: sale.notes,
    };

    const invoice = await Invoice.create(invoiceData);
    return invoice;
  } catch (error) {
    console.error("Error generating invoice from sale:", error);
    throw error;
  }
};

// Helper function to generate invoice from purchase
const generateInvoiceFromPurchase = async (purchase, userInfo = {}) => {
  try {
    // Calculate due date (30 days from now)
    const dueDate = new Date();
    dueDate.setDate(dueDate.getDate() + 30);

    // Use the same invoice number as the purchase
    const invoiceNumber = purchase.purchaseNumber;

    const invoiceData = {
      invoiceNumber: invoiceNumber,
      type: "purchase",
      relatedId: purchase._id,
      relatedModel: "Purchase",
      customerName: purchase.supplierName,
      customerEmail: purchase.supplierEmail,
      customerPhone: purchase.supplierPhone,
      items: purchase.items.map(item => ({
        inventoryId: item.inventoryId,
        name: item.name,
        quantity: item.quantity,
        price: item.cost, // Use cost for purchase invoices
        total: item.total,
      })),
      subtotal: purchase.subtotal,
      tax: purchase.tax,
      shipping: purchase.shipping,
      total: purchase.total,
      dueDate: dueDate,
      issueDate: purchase.createdAt || new Date(),
      paymentStatus: purchase.paymentStatus,
      paidAmount: purchase.paidAmount,
      paymentMethod: purchase.paymentMethod,
      status: purchase.paymentStatus === "paid" ? "paid" : "sent",
      autoGenerated: true,
      generatedFrom: "purchase",
      createdBy: userInfo,
      notes: purchase.notes,
    };

    const invoice = await Invoice.create(invoiceData);
    return invoice;
  } catch (error) {
    console.error("Error generating invoice from purchase:", error);
    throw error;
  }
};

// Get all invoices
exports.getAllInvoices = async (req, res) => {
  try {
    const { 
      type, 
      status, 
      paymentStatus, 
      paymentMethod,
      generatedFrom,
      autoGenerated,
      search, 
      customerName,
      dateFrom,
      dateTo,
      dueDateFrom,
      dueDateTo,
      amountFrom,
      amountTo,
      createdBy,
      sortBy,
      sortOrder,
      relatedId, // Add this for finding invoices by sale/purchase ID
      page = 1, 
      limit = 10 
    } = req.query;
    
    // Build filter object
    const filter = {};
    
    // Basic filters
    if (type) filter.type = type;
    if (status) filter.status = status;
    if (paymentStatus) filter.paymentStatus = paymentStatus;
    if (paymentMethod) filter.paymentMethod = paymentMethod;
    if (generatedFrom) filter.generatedFrom = generatedFrom;
    if (autoGenerated) filter.autoGenerated = autoGenerated === 'true';
    if (relatedId) filter.relatedId = relatedId; // Filter by related sale/purchase ID
    
    // Text search filters
    if (search) {
      filter.$or = [
        { invoiceNumber: { $regex: search, $options: 'i' } },
        { customerName: { $regex: search, $options: 'i' } },
        { customerEmail: { $regex: search, $options: 'i' } },
        { notes: { $regex: search, $options: 'i' } },
      ];
    }
    
    if (customerName) {
      filter.customerName = { $regex: customerName, $options: 'i' };
    }
    
    if (createdBy) {
      filter['createdBy.name'] = { $regex: createdBy, $options: 'i' };
    }
    
    // Date range filters
    if (dateFrom || dateTo) {
      filter.issueDate = {};
      if (dateFrom) filter.issueDate.$gte = new Date(dateFrom);
      if (dateTo) {
        const endDate = new Date(dateTo);
        endDate.setHours(23, 59, 59, 999); // End of day
        filter.issueDate.$lte = endDate;
      }
    }
    
    if (dueDateFrom || dueDateTo) {
      filter.dueDate = {};
      if (dueDateFrom) filter.dueDate.$gte = new Date(dueDateFrom);
      if (dueDateTo) {
        const endDate = new Date(dueDateTo);
        endDate.setHours(23, 59, 59, 999); // End of day
        filter.dueDate.$lte = endDate;
      }
    }
    
    // Amount range filters
    if (amountFrom || amountTo) {
      filter.total = {};
      if (amountFrom) filter.total.$gte = parseFloat(amountFrom);
      if (amountTo) filter.total.$lte = parseFloat(amountTo);
    }

    // Build sort object
    let sort = { createdAt: 1 }; // Default sort - ascending (oldest first)
    if (sortBy) {
      const order = sortOrder === 'asc' ? 1 : -1;
      sort = { [sortBy]: order };
    }

    const skip = (page - 1) * limit;
    const invoices = await Invoice.find(filter)
      .populate('items.inventoryId')
      .populate('relatedId')
      .sort(sort)
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Invoice.countDocuments(filter);

    res.json({
      invoices,
      pagination: {
        current: parseInt(page),
        pages: Math.ceil(total / limit),
        total,
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// Get single invoice
exports.getInvoiceById = async (req, res) => {
  try {
    const invoice = await Invoice.findById(req.params.id)
      .populate('items.inventoryId')
      .populate('relatedId');
    if (!invoice) {
      return res.status(404).json({ error: "Invoice not found" });
    }
    res.json(invoice);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// Create new invoice
exports.createInvoice = async (req, res) => {
  try {
    const invoiceData = {
      ...req.body,
      createdBy: {
        userId: req.user?.id || req.user?._id,
        name: req.user?.name || "Unknown User",
        role: req.user?.role || "staff",
      },
    };

    // Generate invoice number if not provided
    if (!invoiceData.invoiceNumber) {
      const type = invoiceData.type || "sale";
      const count = await Invoice.countDocuments({ type: type });
      const prefix = type === 'sale' ? 'INV' : 'PINV';
      invoiceData.invoiceNumber = `${prefix}-${String(count + 1).padStart(6, '0')}`;
    }

    const invoice = await Invoice.create(invoiceData);
    const populatedInvoice = await Invoice.findById(invoice._id)
      .populate('items.inventoryId')
      .populate('relatedId');
    
    res.status(201).json(populatedInvoice);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// Update invoice
exports.updateInvoice = async (req, res) => {
  try {
    const invoice = await Invoice.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    ).populate('items.inventoryId').populate('relatedId');
    
    if (!invoice) {
      return res.status(404).json({ error: "Invoice not found" });
    }
    res.json(invoice);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// Delete invoice
exports.deleteInvoice = async (req, res) => {
  try {
    const invoice = await Invoice.findByIdAndDelete(req.params.id);
    if (!invoice) {
      return res.status(404).json({ error: "Invoice not found" });
    }
    res.json({ message: "Invoice deleted successfully" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// Generate invoice from sale
exports.generateFromSale = async (req, res) => {
  try {
    const { saleId } = req.params;
    
    // Check if invoice already exists for this sale
    const existingInvoice = await Invoice.findOne({ 
      relatedId: saleId, 
      relatedModel: "Sale" 
    });
    
    if (existingInvoice) {
      return res.status(400).json({ 
        error: "Invoice already exists for this sale",
        invoice: existingInvoice 
      });
    }

    const sale = await Sale.findById(saleId).populate('items.inventoryId');
    if (!sale) {
      return res.status(404).json({ error: "Sale not found" });
    }

    const userInfo = {
      userId: req.user?.id || req.user?._id,
      name: req.user?.name || "Unknown User",
      role: req.user?.role || "staff",
    };

    const invoice = await generateInvoiceFromSale(sale, userInfo);
    const populatedInvoice = await Invoice.findById(invoice._id)
      .populate('items.inventoryId')
      .populate('relatedId');

    res.status(201).json(populatedInvoice);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// Generate invoice from purchase
exports.generateFromPurchase = async (req, res) => {
  try {
    const { purchaseId } = req.params;
    
    // Check if invoice already exists for this purchase
    const existingInvoice = await Invoice.findOne({ 
      relatedId: purchaseId, 
      relatedModel: "Purchase" 
    });
    
    if (existingInvoice) {
      return res.status(400).json({ 
        error: "Invoice already exists for this purchase",
        invoice: existingInvoice 
      });
    }

    const purchase = await Purchase.findById(purchaseId).populate('items.inventoryId');
    if (!purchase) {
      return res.status(404).json({ error: "Purchase not found" });
    }

    const userInfo = {
      userId: req.user?.id || req.user?._id,
      name: req.user?.name || "Unknown User",
      role: req.user?.role || "staff",
    };

    const invoice = await generateInvoiceFromPurchase(purchase, userInfo);
    const populatedInvoice = await Invoice.findById(invoice._id)
      .populate('items.inventoryId')
      .populate('relatedId');

    res.status(201).json(populatedInvoice);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// Update invoice payment status
exports.updatePaymentStatus = async (req, res) => {
  try {
    const { paymentStatus, paidAmount, paymentMethod } = req.body;
    
    const invoice = await Invoice.findById(req.params.id);
    if (!invoice) {
      return res.status(404).json({ error: "Invoice not found" });
    }

    // Validate payment amount
    if (paidAmount > invoice.total) {
      return res.status(400).json({ 
        error: `Payment amount cannot exceed total amount (${invoice.total})` 
      });
    }

    // Update invoice
    invoice.paymentStatus = paymentStatus;
    invoice.paidAmount = paidAmount || 0;
    if (paymentMethod) invoice.paymentMethod = paymentMethod;
    
    // Update status based on payment
    if (paymentStatus === "paid") {
      invoice.status = "paid";
    } else if (paymentStatus === "partial") {
      invoice.status = "sent";
    }

    await invoice.save();

    const populatedInvoice = await Invoice.findById(invoice._id)
      .populate('items.inventoryId')
      .populate('relatedId');

    res.json(populatedInvoice);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// Get invoice statistics
exports.getInvoiceStats = async (req, res) => {
  try {
    const stats = await Invoice.aggregate([
      {
        $group: {
          _id: null,
          totalInvoices: { $sum: 1 },
          totalAmount: { $sum: "$total" },
          paidAmount: { $sum: "$paidAmount" },
          pendingAmount: { $sum: { $subtract: ["$total", "$paidAmount"] } },
          salesInvoices: {
            $sum: { $cond: [{ $eq: ["$type", "sale"] }, 1, 0] }
          },
          purchaseInvoices: {
            $sum: { $cond: [{ $eq: ["$type", "purchase"] }, 1, 0] }
          },
          paidInvoices: {
            $sum: { $cond: [{ $eq: ["$paymentStatus", "paid"] }, 1, 0] }
          },
          unpaidInvoices: {
            $sum: { $cond: [{ $eq: ["$paymentStatus", "unpaid"] }, 1, 0] }
          },
          partialInvoices: {
            $sum: { $cond: [{ $eq: ["$paymentStatus", "partial"] }, 1, 0] }
          },
        }
      }
    ]);

    const result = stats[0] || {
      totalInvoices: 0,
      totalAmount: 0,
      paidAmount: 0,
      pendingAmount: 0,
      salesInvoices: 0,
      purchaseInvoices: 0,
      paidInvoices: 0,
      unpaidInvoices: 0,
      partialInvoices: 0,
    };

    res.json(result);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// Export helper functions for use in other controllers
module.exports.generateInvoiceFromSale = generateInvoiceFromSale;
module.exports.generateInvoiceFromPurchase = generateInvoiceFromPurchase;

